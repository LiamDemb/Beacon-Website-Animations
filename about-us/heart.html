<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width,height=device-height,initial-scale=1"
        />
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
                background: #ffffff;
            }
        </style>
    </head>
    <body>
        <div
            id="protonBrushEmbed_wjigvv7h6s"
            style="
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            "
        ></div>
        <div
            id="__pb_loading"
            style="
                position: absolute;
                left: 8px;
                top: 8px;
                font:
                    12px/1.35 ui-monospace,
                    SFMono-Regular,
                    Menlo,
                    monospace;
                color: #9aa4b2;
                pointer-events: none;
            "
        >
            Loading...
        </div>
        <div
            id="__pb_err"
            style="
                position: absolute;
                left: 8px;
                bottom: 8px;
                right: 8px;
                font:
                    12px/1.35 ui-monospace,
                    SFMono-Regular,
                    Menlo,
                    monospace;
                color: #ff6b6b;
                white-space: pre-wrap;
                pointer-events: none;
            "
        ></div>
        <script>
            ;(function () {
                var scene = {
                    meta: {
                        version: 3,
                        authoredWidth: 1554,
                        authoredHeight: 1554,
                        sourceWidth: 3140,
                        sourceHeight: 1352,
                        crop: { x: 793, y: -101, w: 1554, h: 1554 },
                        background: "#ffffff",
                        particleColor: "#000000",
                        particleColor2: "#d10000",
                        particleColor2Pct: 28,
                    },
                    mode: "spine",
                    animation: {
                        animate: 1,
                        flowSpeed: 20,
                        wobbleAmp: 0,
                        wobbleSpeed: 0,
                        pulseStrength: 0.7,
                        pulseSpeed: 0.1,
                        shapeContainment: 0.5,
                        shapeLeewayPx: 20,
                    },
                    recipe: {
                        density: 0.8,
                        beamVariance: 15,
                        minSize: 3,
                        maxSize: 3,
                        organicWiggle: 0,
                        seed: 276113390,
                    },
                    spines: [
                        {
                            id: "sp_0_0_0",
                            name: "Path 1",
                            visible: true,
                            order: 0,
                            q: 8,
                            pc: 750,
                            pb: "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",
                            rc: 750,
                        },
                        {
                            id: "sp_1_0_1",
                            name: "Path 2",
                            visible: true,
                            order: 1,
                            q: 8,
                            pc: 253,
                            pb: "CzQAKQs06CgLNLkoCzShKAs0oSgLNIkoCzRbKAs0KygLNPwnCzTkJws05CcLNMwnCzSeJws0hicLNIYnCzRuJws0PycLNCcnCzQnJws0DycLNOAmCzSwJgs0giYLNGomCzRqJgs0UiYLNCMmCzQLJgs0CyYLNPMlCzTFJQs0rSULNK0lCzSVJQs0ZiULNDYlCzQHJQs01yQLNKkkCzR5JAs0SiQLNBokCzTsIws0vCMLNI0jCzRdIws0LiMLNP8iCzTQIgs0oCILNHEiCzRBIgs0EyILNOMhCzS0IQs0hCELNFYhCzQmIQs09yALNMcgCzSYIAs0aCALNDogCzQKIAs02x8LNKsfCzR9Hws0TR8LNB4fCzTuHgs0vx4LNI8eCzRhHgs0MR4LNAIeCzTSHQs0pB0LNHQdCzRFHQs0FR0MNOYcDjS2HBI0iBwYNFgcHzQqHCg0+xszNM4bQDSgG040cxteNEYbbzQbG4M07xqXNMUarjSbGsU0cxrfNEoa+jQkGhc1/hk0NdkZUzW1GXM1kxmVNXEZtjVQGdg1Lhn5NQ0ZGzbrGDw2yhheNqgYfzaHGKE2ZhjBNkUY4zYjGAQ3AhgVN/EXFTfxFyY34BdHN78XWDeuF1g3rhdpN50Xijd8F5s3axebN2sXrDdaF803ORfeNygX3jcoF+83FxcQOPYWITjlFiE45RYyONQWUzizFmQ4ohZkOKIWdTiRFpY4cBanOF8WpzhfFrg4ThbZOC0W6jgdFuo4HRb7OAwWGznrFSw52hUsOdoVPTnJFV45qBVvOZcVbzmXFYA5hhWhOWUVsjlUFbI5VBXDOUMV5DkiFfU5ERX1OREVBjoAFSc63xQ4Os4UODrOFEk6vRRqOpwUezqLFHs6ixSMOnoUrTpZFL46SBS+OkgUzzo3FPA6FhQBOwUUATsFFBI79BMzO9QTVzu1E307mROlO38TzjtpE/o7VhMmPEYTVDw5E4I8MBOxPCsT4DwpExA9KhM+PS8TbT04E5o9QxPIPVMT8j1lEx0+exNFPpQTaz6wE48+zhOxPvAT0D4TFOw+ORQGP2EUHD+LFC8/tRQ/P+IUTD8PFVU/PhVbP20VXT+cFVw/yxVXP/sVTz8oFkM/VxY0P4MWIT+vFgw/2RbyPgEX1z4nF7g+TBeYPm0Xdj6PF1U+sBczPtIXEj7zF/A9FRjPPTYYrT1YGI09eRhrPZsYSj28GCg93hgHPf8Y5TwhGcQ8QhmiPGQZgTyFGV88phk+PMcZHDzpGfs7ChrZOywauDtNGpY7bxp1O5AaUzuyGjM70xoRO/Ua8DoWG846OButOlkbizp7G2o6nBtIOr4bNzrOGw==",
                            rc: 253,
                        },
                        {
                            id: "sp_2_0_2",
                            name: "Path 3",
                            visible: true,
                            order: 2,
                            q: 8,
                            pc: 726,
                            pb: "FS4AKf0tACnOLQApni0AKW8tACk/LQApEC0AKeAsACmxLAApgSwAKVIsACkiLAAp8ysAKcMrACmVKwApZSsAKTYrACkeKwApHisAKQYrACnXKgApvyoAKb8qACmnKgApeCoAKWAqAClgKgApSCoAKRkqACkBKgApASoAKekpACm6KQApoikAKaIpACmKKQApWykAKUMpAClDKQApKykAKfwoACnkKAAp5CgAKcwoACmdKAAphSgAKYUoACltKAApPigAKSYoACkmKAApDigAKeAnACnIJwApyCcAKbAnACmBJwApaScAKWknAClRJwApIicAKQonACkKJwAp8iYAKcMmACmTJgApZCYAKTQmACkFJgAp1SUAKaYlACl2JQApRyUAKRclACnoJAApuCQAKYkkAClZJAApKyQAKfsjACnRI/EoySPgKMkjyCjJI64oySOWKMkjgijJI2ooySNPKMkjNyjJIyMoySMLKMkj8CfJI9gnySPEJ8kjrCfJI5EnySN5J8kjZSfJI00nySMzJ8kjGyfJIwYnySPuJskj1CbJI7wmySOnJskjjybJI3UmySNdJskjSCbJIzAmySMWJskj/iXJI+klySPRJckjtyXJI58lySOKJckjciXJI1glySNAJckjKyXJIxMlySP5JMkj4STJI80kySO1JMkjmiTJI4IkySNuJMkjViTJIzskySMjJMkjDyTJI/cjySPcI8kjxCPJI7AjySOYI8kjfiPJI2YjxyNRI8MjOSO7IyUjrSMRI6Aj/SKTI+kihiPWInkjwiJrI64iXiOaIlEjhyJEI3MiNyNfIikjSyIdIzgiDyMkIgIjECL1Ivwh6CLpIdsi1SHNIsEhwCKtIbMimiGmIoYhmSJyIYsiXiF/IkshcSI3IWQiIyFXIg8hSiL8ID0i6CAwItQgIiLAIBUirSAIIpkg+yGFIO4hcSDhIV4g1CFKIMYhNiC5ISIgrCEPIJ8h+x+SIecfhCHTH3ghwB9qIawfXSGYH1AhhB9DIXEfNiFdHyghSR8bITUfDiEiHwEhDh/0IPoe5iDmHtog0x7MIL8evyCrHrIglx6lIIQemCBwHoogXB59IEgecCA1HmMgIR5WIA0eSCD5HTwg5h0uINIdISC+HRQgqh0HIJcd+h+DHewfbx3fH1sd0h9IHcUfNB24HyAdqx8NHZ4f+RyQH+Ucgx/SHHYfvhxpH6ocXB+XHE8fgxxBH28cNR9cHCcfSBwaHzQcDR8gHAAfDRzzHvkb5R7lG9ge0RvLHr4bvh6qG7EelhujHoIblx5vG4keWxt8Hkcbbx4zG2IeIBtVHgwbRx74Gjoe5BotHtEaIB69GhMeqRoFHpUa+R2CGuwdbRrgHVka1B1EGskdMBq+HRsasx0FGqgd8BmfHdsZlR3FGYwdrxmDHZgZex2DGXMdbBlsHVUZZR0+GV4dKBlYHREZUh36GE0d4xhIHcwYRB21GEAdnRg8HYUYOR1vGDcdVxg1HT8YMx0nGDEdEBgxHfgXMB3gFzAdyBcwHbEXMB2ZFzAdgRcwHWkXMB1SFzAdOhcwHSIXMB0KFzAd8xYwHdsWMB3DFjAdqxYwHZQWMB18FjAdZBYwHUwWMB02FjAdHhYwHQYWMB3uFTAd1xUwHb8VMB2nFTAdjxUwHXgVMB1gFTAdSBUwHTAVMB0ZFTAdARUwHekUMB3RFDAduhQwHaIUMB2KFDAdchQwHVsUMB1DFDAdKxQwHRMUMB38EzAd5BMwHcwTMB20EzAdnRMwHYUTMB1tEzAdVRMwHT4TMB0mEzAdDhMwHfYSMB3fEjAdxxIwHa8SMB2XEjAdgRIwHWkSMB1REjAdORIwHSISMB0KEjAd8hEwHdoRMB3DETAdqxEwHZMRMB17ETAdZBEwHUwRMB00ETAdHBEwHQURMB3tEDAd1RAwHb0QMB2mEDAdjhAwHXYQMB1eEDAdRxAwHS8QMB0XEDAd/w8wHegPMB3QDzAduA8wHaAPMB2JDzAdcQ8wHVkPMB1BDzAdKg8wHRIPMB36DjAd4g4wHcwOMB20DjAdnA4wHYQOMB1tDjAdVQ4wHT0OMB0lDjAdDg4wHfYNMB3eDTAdxg0wHa8NMB2XDTAdfw0wHWcNMB1QDTAdOA0wHSANMB0IDTAd8QwwHdkMMB3BDDAdqQwwHZIMMB16DDAdYgwwHUoMMB0zDDAdGwwwHQMMMB3rCzAd1AswHbwLMB2kCzAdjAswHXULMB1dCzAdRQswHS0LMB0XCzAd/wowHecKMB3PCjAduAowHaAKMB2ICjAdcAoxHVkKMx1BCjYdKQo5HREKPh37CUMd4wlJHcwJUB21CVgdoAlhHYkJah10CXUdXgl/HUoJjB01CZgdIQmmHQ0JtB37CMMd6AjSHdYI4x3ECPMdtAgEHqQIFx6UCCkehQg8HngIUB5qCGQeXQh5HlEIjR5HCKMePAi5HjMIzx4qCOUeIwj8HhwIEx8VCCofEAhBHwwIWB8JCHAfBgiIHwQInx8ECLcfBAjPHwUI5x8GCP4fCQgVIA0ILSARCEQgFwhaIB0IcSAkCIggLAieIDUIsyA+CMkgSAjeIFQI8yBgCAYhbAgaIXoILSGICEAhlwhRIaYIYiG2CHMhxwiDIdkIkiHqCKEh/QivIREJvSEkCckhOAnVIU0J4CFiCeoheAnzIY0J/CGjCQQiugkLItEJESLnCRYi/gkaIhYKHSIuCiAiRAoiIlwKIiJ0CiMijAojIqMKIyK7CiMi0wojIusKIyICCyMiGgsjIjILIyJKCyMiYQsjInkLIyKRCyMiqQsjIsALIyLYCyMi8AsjIggMIyIfDCMiNwwjIk8MIyJnDCMifgwjIpYMIyKuDCMixgwjItwMIyL0DCMiDA0jIiQNIyI7DSMiUw0jImsNIyKDDSMimg0jIrINIyLKDSMi4g0jIvkNIyIRDiMiKQ4jIkEOIyJYDiMicA4jIogOIyKgDiMitw4jIs8OIyLnDiMi/w4jIhYPIyIuDyMiRg8jIl4PIyJ1DyMijQ8jIqUPIyK9DyMi1A8jIuwPIyIEECMiHBAjIjMQIyJLECMiYxAjInsQIyKRECMiqRAjIsEQIyLZECMi8BAjIggRIyIgESMiOBEjIk8RIyJnESMifxEjIpcRIyKuESMixhEjIt4RIyL2ESMiDRIjIiUSIyI9EiMiVRIjImwSIyKEEiMinBIjIrQSIyLLEiMi4xIjIvsSIyITEyMiKhMjIkITIyJaEyMichMjIokTIyKhEyMiuRMjItETIyLoEyMiABQjIhgUIyIwFCMiRhQjIl4UIyJ2FCMijhQjIqUUIyK9FCQi1RQmIu0UKCIEFSsiHBUuIjQVMiJLFTciYhU9InkVQyKQFUoipxVRIr0VWSLTFWIi6hVrIgAWdSIVFn8iKhaKIj8WliJUFqIiaBavInwWvSKQFssioxbZIrYW6CLIFvci2hYHI+wWFyP9FigjDhc5Ix8XSiMwF1ojQBdrI1EXfCNiF40jcxedI4MXriOUF78jpRfQI7YX4SPGF/Ej1xcCJOgXEyT5FyQkCRg1JBoYRiQrGFckPBhnJEwYeCRdGIkkbhiaJH8YqiSPGLskoBjMJLEY3STCGO0k0hj+JOMYDyX0GCAlBRkwJRYZQSUnGVIlNxljJUgZcyVZGYQlahmVJXsZpiWMGbYlnBnHJa0Z2CW+Geklzxn5Jd8ZCibwGRsmARosJhIaPCYiGk0mMxpeJkQabyZVGoAmZRqRJnYaoSaHGrImmBrDJqga1Ca5GuUmyhr2JtsaBifrGhcn/BooJw0bOSceG0knLhtaJz8baydQG3wnYRuMJ3EbnSeCG64nkxu/J6Qbzye1G+AnxhvpJ84b",
                            rc: 726,
                        },
                        {
                            id: "sp_3_0_3",
                            name: "Path 4",
                            visible: true,
                            order: 3,
                            q: 8,
                            pc: 337,
                            pb: "FS4AKRUu6CgVLrkoFS6JKBUuWygVLisoFS78JxUuzCcVLp4nFS5uJxUuPycVLg8nFS7gJhUusCYVLoImFS5SJhUuIyYVLvMlFS7FJRUulSUVLmYlFS5OJRUuTiUVLjYlFS4HJRUu7yQVLu8kFS7XJBUuqSQVLpEkFS6RJBUueSQVLkokFS4yJBUuMiQVLhokFS7sIxUu1CMVLtQjFS68IxUujSMVLnUjFS51IxUuXSMVLi8jFS4XIxUuFiMVLv4iFS7QIhUuuCIVLrgiFS6gIhUucSIVLlkiFS5ZIhUuQSIVLhMiFS77IRUu+yEVLuMhFS60IRUunCEVLpwhFS6EIRUuViEVLj4hFS4+IRUuJiEVLvcgFS7fIBUu3yAVLscgFS6YIBUugCAVLoAgFS5oIBUuOiAVLiIgFS4iIBUuCiAVLtsfFS7DHxUuwx8VLqsfFS59HxUuZR8VLmUfFS5NHxUuHh8VLgYfFS4GHxUu7h4VLr8eFS6nHhUupx4VLo8eFS5hHhUuSR4VLkkeFS4xHhUuAh4VLuodFS7qHRUu0h0VLqQdFS6MHRUujB0VLnQdFS5FHRUuLR0VLi0dFS4VHRQu5hwULs4cFC7OHBIuthwOLogcDC5wHAwucBwILlgcAS4qHP0tExz9LRMc+C37G+0tzhvnLbcb5y23G+AtoBvSLXMbyy1dG8stXRvCLUYbsS0bG6gtBRuoLQUbnS3vGoktxRp+LbAafi2wGnItmxpbLXMaQS1KGiYtJBoJLf4Z7CzZGd0sxxndLMcZzSy1Ga0skxmcLIIZnCyCGYsscRlqLFAZWSw/GVksPxlILC4ZJywNGRYs/BgWLPwYBSzrGOQryhjCK6gYoSuHGJArdxiQK3cYfytmGF8rRRhOKzQYTis0GD0rIxgcKwIYCyvxFwsr8Rf6KuAX2Sq/F8gqrhfIKq4XtyqdF5YqfBeFKmsXhSprF3QqWhdTKjkXQiooF0IqKBcxKhcXECr2Fv8p5Rb/KeUW7inUFs0psxarKZEWiilwFmgpThZHKS4WJSkMFgUp6xX0KNoV9CjaFeMoyRXCKKgVsSiXFbEolxWgKIYVfyhlFV0oQxU8KCIVKygRFSsoERUaKAAV+SffFOgnzhToJ84U1ye9FLYnnBSlJ4sUpSeLFJQnehRzJ1kUYidIFGInSBRRJzcUMCcWFB8nBRQfJwUUDif0E+0m1BPJJrUToyaZE3smfxNSJmkTJiZWE/olRhPMJTkTniUwE28lKxNAJSkTECUqE+IkLxOzJDgThiRDE1gkUxMuJGUTAyR7E9sjlBO1I7ATkSPOE28j8BNQIxMUNCM5FBojYRQEI4sU8SK1FOEi4hTUIg8VyyI+FcUibRXDIpwVxCLLFcki+xXRIigW3SJXFuwigxb/Iq8WFCPZFi4jARdJIycXaCNMF4gjbReZI34XmSN+F6ojjxfLI7AX3CPBF9wjwRftI9IXDiTzFx8kBBgfJAQYMCQVGFEkNhhiJEcYYiRHGHMkWBiTJHkYpCSKGKQkihi1JJsY1iS8GOckzRjnJM0Y+CTeGBkl/xgqJRAZKiUQGTslIRlcJUIZbSVTGW0lUxl+JWQZnyWFGbAllRmwJZUZwSWmGeIlxxnzJdgZ8yXYGQQm6RklJgoaNiYbGjYmGxpHJiwaaCZNGnkmXhp5Jl4aiiZvGqsmkBq8JqEavCahGs0mshrtJtMa/ibkGv4m5BoPJ/UaMCcWG0EnJxtBJycbUic4G3MnWRuEJ2obhCdqG5Unexu2J5wbxyetG8cnrRvYJ74b6SfOGw==",
                            rc: 337,
                        },
                        {
                            id: "sp_4_0_4",
                            name: "Path 5",
                            visible: true,
                            order: 4,
                            q: 8,
                            pc: 656,
                            pb: "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",
                            rc: 656,
                        },
                    ],
                    shape: null,
                    packed: null,
                }
                var root = document.getElementById(
                    "protonBrushEmbed_wjigvv7h6s",
                )
                if (!root) {
                    return
                }
                var __pc1 = "#000000"
                var __pc2 = "#d10000"
                var __pc2t = Math.max(0, Math.min(1, 28 / 100))
                var __errEl = document.getElementById("__pb_err")
                function __showErr(msg) {
                    try {
                        if (__errEl) {
                            __errEl.textContent = String(msg || "")
                        }
                    } catch (e) {}
                }
                var __loadEl = document.getElementById("__pb_loading")
                function __hideLoading() {
                    try {
                        if (__loadEl && __loadEl.parentNode) {
                            __loadEl.parentNode.removeChild(__loadEl)
                        }
                    } catch (e) {}
                }
                function __post(s, p) {
                    try {
                        if (window.parent && window.parent !== window) {
                            window.parent.postMessage(
                                Object.assign(
                                    { type: "protonBrushEmbed", status: s },
                                    p || {},
                                ),
                                "*",
                            )
                        }
                    } catch (e) {}
                }
                __post("boot")
                window.addEventListener("error", function (e) {
                    __showErr((e && e.message) || e)
                    __post("error", { message: (e && e.message) || String(e) })
                })
                window.addEventListener("unhandledrejection", function (e) {
                    __showErr((e && e.reason) || e)
                    __post("rejection", {
                        message: String((e && e.reason) || e),
                    })
                })
                var canvas = document.createElement("canvas")
                canvas.style.width = "100%"
                canvas.style.height = "100%"
                canvas.style.display = "block"
                canvas.style.position = "absolute"
                canvas.style.left = "0"
                canvas.style.top = "0"
                root.appendChild(canvas)
                var ctx = canvas.getContext("2d", {
                    alpha: false,
                    desynchronized: true,
                })
                var dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1))
                var authoredW = scene.meta.authoredWidth || 600,
                    authoredH = scene.meta.authoredHeight || 400
                var sourceW = scene.meta.sourceWidth || authoredW,
                    sourceH = scene.meta.sourceHeight || authoredH
                var crop = scene.meta.crop || null
                var cropX = crop ? crop.x || 0 : 0
                var cropY = crop ? crop.y || 0 : 0
                var scale = 1,
                    offX = 0,
                    offY = 0,
                    viewW = 0,
                    viewH = 0
                var __postedResize = 0
                function resize() {
                    var r = root.getBoundingClientRect()
                    viewW = Math.max(1, Math.floor(r.width))
                    viewH = Math.max(1, Math.floor(r.height))
                    if (viewH <= 1) {
                        viewH = Math.max(1, window.innerHeight || 1)
                    }
                    canvas.width = Math.floor(viewW * dpr)
                    canvas.height = Math.floor(viewH * dpr)
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
                    scale = Math.min(viewW / authoredW, viewH / authoredH)
                    offX = (viewW - authoredW * scale) / 2
                    offY = (viewH - authoredH * scale) / 2
                    if (!__postedResize) {
                        __postedResize = 1
                        __post("resize", {
                            viewW: viewW,
                            viewH: viewH,
                            authoredW: authoredW,
                            authoredH: authoredH,
                            scale: scale,
                            offX: offX,
                            offY: offY,
                        })
                    }
                }
                window.addEventListener("resize", resize)
                resize()
                var __tries = 0
                ;(function __settle() {
                    __tries++
                    resize()
                    if (__tries < 30) {
                        setTimeout(__settle, 33)
                    }
                })()
                function hash(n) {
                    n = (n << 13) ^ n
                    return (
                        ((n * (n * n * 15731 + 789221) + 1376312589) &
                            0x7fffffff) /
                        2147483647
                    )
                }
                function lerp(a, b, t) {
                    return a + (b - a) * t
                }
                function smooth(t) {
                    return t * t * (3 - 2 * t)
                }
                function noise2(x, y) {
                    var xi = Math.floor(x),
                        yi = Math.floor(y)
                    var xf = x - xi,
                        yf = y - yi
                    var a = hash(xi * 374761 + yi * 668265)
                    var b = hash((xi + 1) * 374761 + yi * 668265)
                    var c = hash(xi * 374761 + (yi + 1) * 668265)
                    var d = hash((xi + 1) * 374761 + (yi + 1) * 668265)
                    var u = smooth(xf),
                        v = smooth(yf)
                    return lerp(lerp(a, b, u), lerp(c, d, u), v)
                }
                function hash01(seed) {
                    var x = Math.sin(seed * 12.9898) * 43758.5453
                    return x - Math.floor(x)
                }
                function mulberry32(a) {
                    return function () {
                        var t = (a += 0x6d2b79f5)
                        t = Math.imul(t ^ (t >>> 15), t | 1)
                        t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
                        return ((t ^ (t >>> 14)) >>> 0) / 4294967296
                    }
                }
                function makeGaussian(rand) {
                    var spare = null
                    return function (mean, sd) {
                        if (spare !== null) {
                            var v = spare
                            spare = null
                            return mean + sd * v
                        }
                        var u = 0,
                            v = 0
                        while (u === 0) u = rand()
                        while (v === 0) v = rand()
                        var mag = Math.sqrt(-2 * Math.log(u))
                        var z0 = mag * Math.cos(2 * Math.PI * v)
                        var z1 = mag * Math.sin(2 * Math.PI * v)
                        spare = z1
                        return mean + sd * z0
                    }
                }
                function b64ToU8(b64) {
                    var bin = atob(b64 || "")
                    var len = bin.length
                    var u8 = new Uint8Array(len)
                    for (var i = 0; i < len; i++) u8[i] = bin.charCodeAt(i)
                    return u8
                }
                var mode = "spine"
                var anim = scene.animation || {}
                var recipe = scene.recipe || {}
                function map(v, a1, a2, b1, b2) {
                    return b1 + ((v - a1) * (b2 - b1)) / Math.max(1e-6, a2 - a1)
                }
                var spines = scene.spines || []
                if ((!spines || !spines.length) && scene.spine)
                    spines = [scene.spine]
                var spCount = spines.length | 0
                var spQ = new Array(spCount),
                    spN = new Array(spCount),
                    spPts = new Array(spCount),
                    spCum = new Array(spCount),
                    spLen = new Array(spCount)
                for (var sidx = 0; sidx < spCount; sidx++) {
                    var s = spines[sidx]
                    if (!s || !s.pb || !s.pc) {
                        spN[sidx] = 0
                        spLen[sidx] = 0
                        continue
                    }
                    spQ[sidx] = s.q || 1
                    spN[sidx] = s.pc | 0
                    var u8 = b64ToU8(s.pb)
                    spPts[sidx] = new Int16Array(u8.buffer)
                    var cum = new Float32Array(spN[sidx])
                    cum[0] = 0
                    var L = 0
                    for (var i = 0; i < spN[sidx] - 1; i++) {
                        var ax = spPts[sidx][i * 2] / spQ[sidx],
                            ay = spPts[sidx][i * 2 + 1] / spQ[sidx]
                        var bx = spPts[sidx][(i + 1) * 2] / spQ[sidx],
                            by = spPts[sidx][(i + 1) * 2 + 1] / spQ[sidx]
                        L += Math.hypot(bx - ax, by - ay)
                        cum[i + 1] = L
                    }
                    spCum[sidx] = cum
                    spLen[sidx] = L
                }
                function pointAtS(si, s) {
                    var pts = spPts[si],
                        cum = spCum[si],
                        N = spN[si] | 0,
                        L = spLen[si] || 0,
                        Q = spQ[si] || 1
                    if (!pts || !cum || N < 2 || L <= 0) {
                        return { x: 0, y: 0, nx: 0, ny: 1 }
                    }
                    var ss = s % L
                    if (ss < 0) ss += L
                    var lo = 0,
                        hi = N - 2
                    while (lo <= hi) {
                        var mid = (lo + hi) >> 1
                        if (ss < cum[mid]) hi = mid - 1
                        else if (ss > cum[mid + 1]) lo = mid + 1
                        else {
                            lo = mid
                            break
                        }
                    }
                    var idx = Math.max(0, Math.min(N - 2, lo))
                    var ax = pts[idx * 2] / Q,
                        ay = pts[idx * 2 + 1] / Q
                    var bx = pts[(idx + 1) * 2] / Q,
                        by = pts[(idx + 1) * 2 + 1] / Q
                    var segLen = Math.max(1e-6, cum[idx + 1] - cum[idx])
                    var t = (ss - cum[idx]) / segLen
                    var x = ax + (bx - ax) * t,
                        y = ay + (by - ay) * t
                    var tx = (bx - ax) / segLen,
                        ty = (by - ay) / segLen
                    return { x: x, y: y, nx: -ty, ny: tx }
                }
                var density = +recipe.density || 1
                var beam = +recipe.beamVariance || 20
                var minS = +recipe.minSize || 1
                var maxS = +recipe.maxSize || 8
                var seed = recipe.seed >>> 0 || 1
                var rand = mulberry32(seed)
                var gauss = makeGaussian(rand)
                var particles = null
                function buildSpineParticles() {
                    if (particles) return particles
                    particles = []
                    var CL = 4
                    for (var si = 0; si < spCount; si++) {
                        var s = spines[si] || {}
                        if (s.visible === false) continue
                        var pts = spPts[si],
                            cum = spCum[si],
                            N = spN[si] | 0,
                            Q = spQ[si] || 1
                        if (!pts || !cum || N < 2) continue
                        for (var i = 0; i < N - 1; i++) {
                            var ax = pts[i * 2] / Q,
                                ay = pts[i * 2 + 1] / Q
                            var bx = pts[(i + 1) * 2] / Q,
                                by = pts[(i + 1) * 2 + 1] / Q
                            var dx = bx - ax,
                                dy = by - ay
                            var segLen = Math.hypot(dx, dy)
                            if (segLen < 1e-6) continue
                            var count = Math.min(
                                2500,
                                Math.ceil(segLen * density),
                            )
                            var segStartS = cum[i] || 0
                            for (var j = 0; j < count; j++) {
                                var tt = j / Math.max(1, count)
                                var baseS = segStartS + tt * segLen
                                var offN = gauss(0, beam)
                                var offT = gauss(0, beam * 0.15)
                                var limN = beam * CL
                                var limT = beam * 0.15 * CL
                                if (offN > limN) offN = limN
                                else if (offN < -limN) offN = -limN
                                if (offT > limT) offT = limT
                                else if (offT < -limT) offT = -limT
                                var dist = Math.abs(offN)
                                var size = map(dist, 0, beam * 2, maxS, minS)
                                if (size < minS) size = minS
                                else if (size > maxS) size = maxS
                                particles.push({
                                    si: si,
                                    s: baseS,
                                    n: offN,
                                    t: offT,
                                    z: size,
                                    seed:
                                        ((si + 1) * 100000000 +
                                            i * 100000 +
                                            j) >>>
                                        0,
                                })
                            }
                        }
                    }
                    return particles
                }
                function init() {
                    if (mode === "shape") {
                        var sh = scene.shape || {}
                        var svg = sh.svg || ""
                        if (!svg) {
                            __showErr("Shape mode: missing SVG")
                            return Promise.resolve(false)
                        }
                        var leeway = (anim.shapeLeewayPx || 0) | 0
                        return buildShapeMask(svg, leeway).then(
                            function (mask) {
                                shapeMask = mask
                                var stride = 2
                                var r = bboxAndPts(
                                    mask.core,
                                    mask.w,
                                    mask.h,
                                    stride,
                                )
                                shapePts = r.pts
                                __post("shape", { pts: shapePts.length })
                                return true
                            },
                        )
                    }
                    return Promise.resolve(true)
                }
                var __postedParticles = 0
                function renderFrame(tms) {
                    var t = tms / 1000
                    var wobA = anim.wobbleAmp || 0,
                        wobS = anim.wobbleSpeed || 0,
                        pulse = anim.pulseStrength || 0,
                        pulseS = anim.pulseSpeed || 0
                    var frameStep = Math.floor(
                        t * Math.max(0.0001, pulseS) * 10,
                    )
                    ctx.globalAlpha = 1
                    ctx.fillStyle = "#ffffff"
                    ctx.fillRect(0, 0, viewW, viewH)
                    ctx.fillStyle = __pc1
                    if (mode === "shape") {
                        var ps = buildShapeParticles()
                        if (!__postedParticles) {
                            __postedParticles = 1
                            __post("particles", { count: ps.length })
                            __hideLoading()
                        }
                        var cont = +anim.shapeContainment || 0.5
                        var mix = __pc2t > 0
                        for (var i = 0; i < ps.length; i++) {
                            var p = ps[i]
                            if (anim.animate) {
                                if (wobA > 0) {
                                    var ax =
                                        (noise2(p.seed * 0.01, t * wobS) -
                                            0.5) *
                                        2
                                    var ay =
                                        (noise2(p.seed * 0.02, 100 + t * wobS) -
                                            0.5) *
                                        2
                                    p.vx += ax * (wobA * 0.12)
                                    p.vy += ay * (wobA * 0.12)
                                }
                                p.vx *= 0.9
                                p.vy *= 0.9
                                p.x += p.vx
                                p.y += p.vy
                                var inCore =
                                    alphaAt(shapeMask, p.x, p.y, "core") > 0
                                if (!inCore) {
                                    var inLew =
                                        alphaAt(shapeMask, p.x, p.y, "leeway") >
                                        0
                                    var k = inLew
                                        ? 0.02 + 0.12 * cont
                                        : 0.06 + 0.22 * cont
                                    p.vx += (p.x0 - p.x) * k
                                    p.vy += (p.y0 - p.y) * k
                                    if (!inLew) {
                                        var cl = findNearestInside(
                                            shapeMask,
                                            p.x,
                                            p.y,
                                        )
                                        if (cl) {
                                            p.x = cl.x
                                            p.y = cl.y
                                            p.vx *= 0.2
                                            p.vy *= 0.2
                                        }
                                    }
                                }
                            }
                            var alpha = 200 / 255
                            if (anim.animate && pulse > 0) {
                                var phase =
                                    p.seed * 0.01 + t * pulseS * Math.PI * 2
                                var vis =
                                    1 -
                                    pulse +
                                    pulse * (0.5 + 0.5 * Math.sin(phase))
                                var r = hash01(
                                    (p.seed || i) + frameStep * 10007,
                                )
                                if (r > vis) continue
                                alpha = (80 + 175 * vis) / 255
                            }
                            var rx = offX + (p.x - cropX) * scale
                            var ry = offY + (p.y - cropY) * scale
                            var radPx = Math.max(((p.z || 1) * scale) / 2, 0.6)
                            if (mix) {
                                ctx.fillStyle =
                                    hash01(p.seed || i) < __pc2t ? __pc2 : __pc1
                            }
                            ctx.globalAlpha = alpha
                            ctx.beginPath()
                            ctx.arc(rx, ry, radPx, 0, Math.PI * 2)
                            ctx.fill()
                        }
                        ctx.globalAlpha = 1
                        requestAnimationFrame(renderFrame)
                        return
                    }
                    var flow = anim.flowSpeed || 0
                    var ps = buildSpineParticles()
                    if (!__postedParticles) {
                        __postedParticles = 1
                        __post("particles", { count: ps.length })
                        __hideLoading()
                    }
                    var mix = __pc2t > 0
                    for (var i = 0; i < ps.length; i++) {
                        var p = ps[i]
                        var si = p.si || 0
                        var x = 0,
                            y = 0,
                            alpha = 200 / 255
                        var s = (p.s || 0) + (anim.animate ? flow * t : 0)
                        var base = pointAtS(si, s + (p.t || 0))
                        x = base.x + base.nx * (p.n || 0)
                        y = base.y + base.ny * (p.n || 0)
                        if (anim.animate && wobA > 0) {
                            var pr = p.seed || i
                            var n1 = noise2(pr * 0.01, t * wobS) - 0.5
                            var n2 = noise2(pr * 0.02, 100 + t * wobS) - 0.5
                            x += n1 * 2 * wobA
                            y += n2 * 2 * wobA
                        }
                        var L = spLen[si] || 0
                        if (anim.animate && pulse > 0 && L > 0) {
                            var phase =
                                (s / L) * Math.PI * 2 + t * pulseS * Math.PI * 2
                            var vis =
                                1 -
                                pulse +
                                pulse * (0.5 + 0.5 * Math.sin(phase))
                            var pr2 = (p.seed || i) + frameStep * 10007
                            var r = hash01(pr2)
                            if (r > vis) continue
                            alpha = (80 + 175 * vis) / 255
                        }
                        var rx = offX + (x - cropX) * scale
                        var ry = offY + (y - cropY) * scale
                        var radPx = Math.max(((p.z || 1) * scale) / 2, 0.6)
                        if (mix) {
                            ctx.fillStyle =
                                hash01(p.seed || i) < __pc2t ? __pc2 : __pc1
                        }
                        ctx.globalAlpha = alpha
                        ctx.beginPath()
                        ctx.arc(rx, ry, radPx, 0, Math.PI * 2)
                        ctx.fill()
                    }
                    ctx.globalAlpha = 1
                    requestAnimationFrame(renderFrame)
                }
                init()
                    .then(function (ok) {
                        if (ok === false) return
                        __hideLoading()
                        requestAnimationFrame(renderFrame)
                    })
                    .catch(function (e) {
                        __showErr(e && e.message ? e.message : e)
                        __post("error", {
                            message: String(e && e.message ? e.message : e),
                        })
                    })
            })()
        </script>
    </body>
</html>
