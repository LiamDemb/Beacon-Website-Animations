<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width,height=device-height,initial-scale=1"
        />
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
                background: #e6eef5;
            }
        </style>
    </head>
    <body>
        <div
            id="protonBrushEmbed_41p5c7v8bm"
            style="
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            "
        ></div>
        <div
            id="__pb_loading"
            style="
                position: absolute;
                left: 8px;
                top: 8px;
                font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, monospace;
                color: #9aa4b2;
                pointer-events: none;
            "
        >
            Loading...
        </div>
        <div
            id="__pb_err"
            style="
                position: absolute;
                left: 8px;
                bottom: 8px;
                right: 8px;
                font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, monospace;
                color: #ff6b6b;
                white-space: pre-wrap;
                pointer-events: none;
            "
        ></div>
        <script>
            ;(function () {
                var scene = {
                    meta: {
                        version: 3,
                        authoredWidth: 1151,
                        authoredHeight: 929,
                        sourceWidth: 3140,
                        sourceHeight: 1352,
                        crop: { x: 994, y: 211, w: 1151, h: 929 },
                        background: "#e6eef5",
                        particleColor: "#000000",
                        particleColor2: "#000000",
                        particleColor2Pct: 0,
                    },
                    mode: "shape",
                    animation: {
                        animate: 1,
                        flowSpeed: 0,
                        wobbleAmp: 1,
                        wobbleSpeed: 2.5,
                        pulseStrength: 0.25,
                        pulseSpeed: 0.1,
                        shapeContainment: 1,
                        shapeLeewayPx: 40,
                    },
                    recipe: {
                        density: 8.52,
                        beamVariance: 20,
                        minSize: 6,
                        maxSize: 6,
                        organicWiggle: 0,
                        seed: 651138623,
                    },
                    spines: [],
                    shape: {
                        svg: '\u003csvg id="Layer_1" enable-background="new 0 0 24 24" height="512" viewBox="0 0 24 24" width="512" xmlns="http://www.w3.org/2000/svg">\u003cpath d="m4.7 17.7c-1-1.1-1.6-2.3-1.6-4.3 0-3.5 2.5-6.6 6-8.2l.9 1.3c-3.3 1.8-4 4.1-4.2 5.6.5-.3 1.2-.4 1.9-.3 1.8.2 3.2 1.6 3.2 3.5 0 .9-.4 1.8-1 2.5-.7.7-1.5 1-2.5 1-1.1 0-2.1-.5-2.7-1.1zm10 0c-1-1.1-1.6-2.3-1.6-4.3 0-3.5 2.5-6.6 6-8.2l.9 1.3c-3.3 1.8-4 4.1-4.2 5.6.5-.3 1.2-.4 1.9-.3 1.8.2 3.2 1.6 3.2 3.5 0 .9-.4 1.8-1 2.5s-1.5 1-2.5 1c-1.1 0-2.1-.5-2.7-1.1z"/>\u003c/svg>',
                    },
                    packed: null,
                }
                var root = document.getElementById(
                    "protonBrushEmbed_41p5c7v8bm"
                )
                if (!root) {
                    return
                }
                var __pc1 = "#000000"
                var __pc2 = "#000000"
                var __pc2t = Math.max(0, Math.min(1, 0 / 100))
                var __errEl = document.getElementById("__pb_err")
                function __showErr(msg) {
                    try {
                        if (__errEl) {
                            __errEl.textContent = String(msg || "")
                        }
                    } catch (e) {}
                }
                var __loadEl = document.getElementById("__pb_loading")
                function __hideLoading() {
                    try {
                        if (__loadEl && __loadEl.parentNode) {
                            __loadEl.parentNode.removeChild(__loadEl)
                        }
                    } catch (e) {}
                }
                function __post(s, p) {
                    try {
                        if (window.parent && window.parent !== window) {
                            window.parent.postMessage(
                                Object.assign(
                                    { type: "protonBrushEmbed", status: s },
                                    p || {}
                                ),
                                "*"
                            )
                        }
                    } catch (e) {}
                }
                __post("boot")
                window.addEventListener("error", function (e) {
                    __showErr((e && e.message) || e)
                    __post("error", { message: (e && e.message) || String(e) })
                })
                window.addEventListener("unhandledrejection", function (e) {
                    __showErr((e && e.reason) || e)
                    __post("rejection", {
                        message: String((e && e.reason) || e),
                    })
                })
                var canvas = document.createElement("canvas")
                canvas.style.width = "100%"
                canvas.style.height = "100%"
                canvas.style.display = "block"
                canvas.style.position = "absolute"
                canvas.style.left = "0"
                canvas.style.top = "0"
                root.appendChild(canvas)
                var ctx = canvas.getContext("2d", {
                    alpha: false,
                    desynchronized: true,
                })
                var dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1))
                var authoredW = scene.meta.authoredWidth || 600,
                    authoredH = scene.meta.authoredHeight || 400
                var sourceW = scene.meta.sourceWidth || authoredW,
                    sourceH = scene.meta.sourceHeight || authoredH
                var crop = scene.meta.crop || null
                var cropX = crop ? crop.x || 0 : 0
                var cropY = crop ? crop.y || 0 : 0
                var scale = 1,
                    offX = 0,
                    offY = 0,
                    viewW = 0,
                    viewH = 0
                var __postedResize = 0
                function resize() {
                    var r = root.getBoundingClientRect()
                    viewW = Math.max(1, Math.floor(r.width))
                    viewH = Math.max(1, Math.floor(r.height))
                    if (viewH <= 1) {
                        viewH = Math.max(1, window.innerHeight || 1)
                    }
                    canvas.width = Math.floor(viewW * dpr)
                    canvas.height = Math.floor(viewH * dpr)
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
                    scale = Math.min(viewW / authoredW, viewH / authoredH)
                    offX = (viewW - authoredW * scale) / 2
                    offY = (viewH - authoredH * scale) / 2
                    if (!__postedResize) {
                        __postedResize = 1
                        __post("resize", {
                            viewW: viewW,
                            viewH: viewH,
                            authoredW: authoredW,
                            authoredH: authoredH,
                            scale: scale,
                            offX: offX,
                            offY: offY,
                        })
                    }
                }
                window.addEventListener("resize", resize)
                resize()
                var __tries = 0
                ;(function __settle() {
                    __tries++
                    resize()
                    if (__tries < 30) {
                        setTimeout(__settle, 33)
                    }
                })()
                function hash(n) {
                    n = (n << 13) ^ n
                    return (
                        ((n * (n * n * 15731 + 789221) + 1376312589) &
                            0x7fffffff) /
                        2147483647
                    )
                }
                function lerp(a, b, t) {
                    return a + (b - a) * t
                }
                function smooth(t) {
                    return t * t * (3 - 2 * t)
                }
                function noise2(x, y) {
                    var xi = Math.floor(x),
                        yi = Math.floor(y)
                    var xf = x - xi,
                        yf = y - yi
                    var a = hash(xi * 374761 + yi * 668265)
                    var b = hash((xi + 1) * 374761 + yi * 668265)
                    var c = hash(xi * 374761 + (yi + 1) * 668265)
                    var d = hash((xi + 1) * 374761 + (yi + 1) * 668265)
                    var u = smooth(xf),
                        v = smooth(yf)
                    return lerp(lerp(a, b, u), lerp(c, d, u), v)
                }
                function hash01(seed) {
                    var x = Math.sin(seed * 12.9898) * 43758.5453
                    return x - Math.floor(x)
                }
                function mulberry32(a) {
                    return function () {
                        var t = (a += 0x6d2b79f5)
                        t = Math.imul(t ^ (t >>> 15), t | 1)
                        t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
                        return ((t ^ (t >>> 14)) >>> 0) / 4294967296
                    }
                }
                function makeGaussian(rand) {
                    var spare = null
                    return function (mean, sd) {
                        if (spare !== null) {
                            var v = spare
                            spare = null
                            return mean + sd * v
                        }
                        var u = 0,
                            v = 0
                        while (u === 0) u = rand()
                        while (v === 0) v = rand()
                        var mag = Math.sqrt(-2 * Math.log(u))
                        var z0 = mag * Math.cos(2 * Math.PI * v)
                        var z1 = mag * Math.sin(2 * Math.PI * v)
                        spare = z1
                        return mean + sd * z0
                    }
                }
                function b64ToU8(b64) {
                    var bin = atob(b64 || "")
                    var len = bin.length
                    var u8 = new Uint8Array(len)
                    for (var i = 0; i < len; i++) u8[i] = bin.charCodeAt(i)
                    return u8
                }
                var mode = "shape"
                var anim = scene.animation || {}
                var recipe = scene.recipe || {}
                function map(v, a1, a2, b1, b2) {
                    return b1 + ((v - a1) * (b2 - b1)) / Math.max(1e-6, a2 - a1)
                }
                var density = +recipe.density || 1
                var beam = +recipe.beamVariance || 20
                var minS = +recipe.minSize || 1
                var maxS = +recipe.maxSize || 8
                var seed = recipe.seed >>> 0 || 1
                var rand = mulberry32(seed)
                var gauss = makeGaussian(rand)
                var shapeMask = null
                var shapePts = null
                var shapeParticles = null
                function ensureSvgBasics(s) {
                    if (!/xmlns=/.test(s || "")) {
                        return String(s || "").replace(
                            /<svg\b/,
                            '<svg xmlns="http://www.w3.org/2000/svg"'
                        )
                    }
                    return String(s || "")
                }
                function inferSvgSize(s) {
                    try {
                        var p = new DOMParser()
                        var d = p.parseFromString(s, "image/svg+xml")
                        var svg = d.querySelector("svg")
                        if (!svg) return { w: 1000, h: 1000 }
                        var vb = svg.getAttribute("viewBox")
                        if (vb) {
                            var parts = vb
                                .trim()
                                .split(/[\s,]+/)
                                .map(Number)
                            if (
                                parts.length === 4 &&
                                parts.every(function (n) {
                                    return isFinite(n)
                                })
                            ) {
                                return {
                                    w: Math.max(1, parts[2]),
                                    h: Math.max(1, parts[3]),
                                }
                            }
                        }
                        var wa = svg.getAttribute("width"),
                            ha = svg.getAttribute("height")
                        var w = wa
                            ? parseFloat(String(wa).replace(/[a-z%]+/gi, ""))
                            : NaN
                        var h = ha
                            ? parseFloat(String(ha).replace(/[a-z%]+/gi, ""))
                            : NaN
                        if (isFinite(w) && isFinite(h) && w > 0 && h > 0)
                            return { w: w, h: h }
                    } catch (e) {}
                    return { w: 1000, h: 1000 }
                }
                function svgToImg(s) {
                    return new Promise(function (res, rej) {
                        try {
                            var blob = new Blob([s], { type: "image/svg+xml" })
                            var url = URL.createObjectURL(blob)
                            var img = new Image()
                            img.crossOrigin = "anonymous"
                            img.onload = function () {
                                try {
                                    URL.revokeObjectURL(url)
                                } catch (e) {}
                                res(img)
                            }
                            img.onerror = function () {
                                try {
                                    URL.revokeObjectURL(url)
                                } catch (e) {}
                                rej(new Error("Failed to load SVG"))
                            }
                            img.src = url
                        } catch (e) {
                            rej(e)
                        }
                    })
                }
                function bboxAndPts(alpha, w, h, stride) {
                    var minX = w,
                        minY = h,
                        maxX = -1,
                        maxY = -1
                    var pts = []
                    for (var y = 0; y < h; y += stride) {
                        for (var x = 0; x < w; x += stride) {
                            if (alpha[y * w + x] > 0) {
                                pts.push([x, y])
                                if (x < minX) minX = x
                                if (y < minY) minY = y
                                if (x > maxX) maxX = x
                                if (y > maxY) maxY = y
                            }
                        }
                    }
                    if (maxX < 0) return { bbox: null, pts: [] }
                    return {
                        bbox: {
                            minX: minX,
                            minY: minY,
                            maxX: maxX,
                            maxY: maxY,
                        },
                        pts: pts,
                    }
                }
                function dilateAlpha(core, w, h, r) {
                    var src = document.createElement("canvas")
                    src.width = w
                    src.height = h
                    var sctx = src.getContext("2d", {
                        willReadFrequently: true,
                    })
                    if (!sctx) return core
                    var id = sctx.createImageData(w, h)
                    for (var i = 0, j = 0; j < core.length; i += 4, j++) {
                        var a = core[j]
                        id.data[i] = 255
                        id.data[i + 1] = 255
                        id.data[i + 2] = 255
                        id.data[i + 3] = a
                    }
                    sctx.putImageData(id, 0, 0)
                    var dst = document.createElement("canvas")
                    dst.width = w
                    dst.height = h
                    var dctx = dst.getContext("2d", {
                        willReadFrequently: true,
                    })
                    if (!dctx) return core
                    dctx.clearRect(0, 0, w, h)
                    dctx.filter = "blur(" + Math.max(1, r) + "px)"
                    dctx.drawImage(src, 0, 0)
                    dctx.filter = "none"
                    var out = dctx.getImageData(0, 0, w, h).data
                    var a2 = new Uint8Array(w * h)
                    for (var k = 0, kk = 0; k < out.length; k += 4, kk++) {
                        a2[kk] = out[k + 3] > 1 ? 255 : 0
                    }
                    return a2
                }
                function buildShapeMask(svgText, leewayPx) {
                    return svgToImg(ensureSvgBasics(svgText)).then(function (
                        img
                    ) {
                        var size = inferSvgSize(svgText)
                        var w = sourceW | 0,
                            h = sourceH | 0
                        var pad = 40
                        var c = document.createElement("canvas")
                        c.width = w
                        c.height = h
                        var g = c.getContext("2d", { willReadFrequently: true })
                        g.clearRect(0, 0, w, h)
                        var dstW = Math.max(1, w - pad * 2),
                            dstH = Math.max(1, h - pad * 2)
                        var srcW = Math.max(
                                1,
                                size.w || img.naturalWidth || img.width || 1
                            ),
                            srcH = Math.max(
                                1,
                                size.h || img.naturalHeight || img.height || 1
                            )
                        var s = Math.min(dstW / srcW, dstH / srcH)
                        var dw = srcW * s,
                            dh = srcH * s
                        var dx = (w - dw) / 2,
                            dy = (h - dh) / 2
                        g.drawImage(img, dx, dy, dw, dh)
                        var data = g.getImageData(0, 0, w, h).data
                        var alpha = new Uint8Array(w * h)
                        for (var i = 0, j = 0; i < data.length; i += 4, j++) {
                            alpha[j] = data[i + 3]
                        }
                        var leeway =
                            leewayPx > 0
                                ? dilateAlpha(alpha, w, h, leewayPx)
                                : alpha
                        return { w: w, h: h, core: alpha, leeway: leeway }
                    })
                }
                function alphaAt(mask, x, y, which) {
                    var ix = x | 0,
                        iy = y | 0
                    if (ix < 0 || iy < 0 || ix >= mask.w || iy >= mask.h)
                        return 0
                    var idx = iy * mask.w + ix
                    return (
                        (which === "leeway" ? mask.leeway : mask.core)[idx] || 0
                    )
                }
                function findNearestInside(mask, x, y) {
                    var maxR = 36,
                        step = 3
                    for (var r = step; r <= maxR; r += step) {
                        var n = Math.max(8, ((Math.PI * 2 * r) / step) | 0)
                        for (var i = 0; i < n; i++) {
                            var a = (i / n) * Math.PI * 2
                            var xx = x + Math.cos(a) * r
                            var yy = y + Math.sin(a) * r
                            if (alphaAt(mask, xx, yy, "leeway") > 0)
                                return { x: xx, y: yy }
                        }
                    }
                    return null
                }
                function buildShapeParticles() {
                    if (shapeParticles) return shapeParticles
                    if (!shapeMask || !shapePts || shapePts.length === 0) {
                        shapeParticles = []
                        return shapeParticles
                    }
                    shapeParticles = []
                    var stride = 2
                    var insideArea = shapePts.length * stride * stride
                    var SHAPE_AREA_SCALE = 5000
                    var target = Math.ceil(
                        (insideArea * (+recipe.density || 0.2)) /
                            SHAPE_AREA_SCALE
                    )
                    var minS = +recipe.minSize || 1
                    var maxS = +recipe.maxSize || 8
                    var seed = recipe.seed >>> 0 || 1
                    var rand = mulberry32(seed)
                    for (var i = 0; i < target; i++) {
                        var pt = shapePts[(rand() * shapePts.length) | 0]
                        var x = pt[0] + (rand() - 0.5) * stride
                        var y = pt[1] + (rand() - 0.5) * stride
                        if (alphaAt(shapeMask, x, y, "core") <= 0) {
                            x = pt[0]
                            y = pt[1]
                        }
                        var size = minS + (maxS - minS) * rand()
                        shapeParticles.push({
                            x: x,
                            y: y,
                            x0: x,
                            y0: y,
                            vx: 0,
                            vy: 0,
                            z: size,
                            seed: i >>> 0,
                        })
                    }
                    return shapeParticles
                }
                function init() {
                    if (mode === "shape") {
                        var sh = scene.shape || {}
                        var svg = sh.svg || ""
                        if (!svg) {
                            __showErr("Shape mode: missing SVG")
                            return Promise.resolve(false)
                        }
                        var leeway = (anim.shapeLeewayPx || 0) | 0
                        return buildShapeMask(svg, leeway).then(function (
                            mask
                        ) {
                            shapeMask = mask
                            var stride = 2
                            var r = bboxAndPts(
                                mask.core,
                                mask.w,
                                mask.h,
                                stride
                            )
                            shapePts = r.pts
                            __post("shape", { pts: shapePts.length })
                            return true
                        })
                    }
                    return Promise.resolve(true)
                }
                var __postedParticles = 0
                function renderFrame(tms) {
                    var t = tms / 1000
                    var wobA = anim.wobbleAmp || 0,
                        wobS = anim.wobbleSpeed || 0,
                        pulse = anim.pulseStrength || 0,
                        pulseS = anim.pulseSpeed || 0
                    var frameStep = Math.floor(
                        t * Math.max(0.0001, pulseS) * 10
                    )
                    ctx.globalAlpha = 1
                    ctx.fillStyle = "#e6eef5"
                    ctx.fillRect(0, 0, viewW, viewH)
                    ctx.fillStyle = __pc1
                    if (mode === "shape") {
                        var ps = buildShapeParticles()
                        if (!__postedParticles) {
                            __postedParticles = 1
                            __post("particles", { count: ps.length })
                            __hideLoading()
                        }
                        var cont = +anim.shapeContainment || 0.5
                        var inv = Math.max(0.001, 1 / Math.max(0.001, scale))
                        var mix = __pc2t > 0
                        for (var i = 0; i < ps.length; i++) {
                            var p = ps[i]
                            if (anim.animate) {
                                if (wobA > 0) {
                                    var ax =
                                        (noise2(
                                            p.seed * 0.013 + 17.13,
                                            t * wobS + 5.37
                                        ) -
                                            0.5) *
                                        2
                                    var ay =
                                        (noise2(
                                            p.seed * 0.017 + 101.7,
                                            t * wobS + 77.1
                                        ) -
                                            0.5) *
                                        2
                                    p.vx += ax * (wobA * 0.12 * inv)
                                    p.vy += ay * (wobA * 0.12 * inv)
                                }
                                p.vx *= 0.9
                                p.vy *= 0.9
                                p.x += p.vx
                                p.y += p.vy
                                var kInside = (0.002 + 0.01 * cont) * inv
                                p.vx += (p.x0 - p.x) * kInside
                                p.vy += (p.y0 - p.y) * kInside
                                var inCore =
                                    alphaAt(shapeMask, p.x, p.y, "core") > 0
                                if (!inCore) {
                                    var inLew =
                                        alphaAt(shapeMask, p.x, p.y, "leeway") >
                                        0
                                    var k = inLew
                                        ? 0.02 + 0.12 * cont
                                        : 0.06 + 0.22 * cont
                                    k *= inv
                                    p.vx += (p.x0 - p.x) * k
                                    p.vy += (p.y0 - p.y) * k
                                    if (!inLew) {
                                        var cl = findNearestInside(
                                            shapeMask,
                                            p.x,
                                            p.y
                                        )
                                        if (cl) {
                                            p.x = cl.x
                                            p.y = cl.y
                                            p.vx *= 0.2
                                            p.vy *= 0.2
                                        } else {
                                            p.x = p.x0
                                            p.y = p.y0
                                            p.vx *= 0.2
                                            p.vy *= 0.2
                                        }
                                    }
                                }
                            }
                            var alpha = 200 / 255
                            if (anim.animate && pulse > 0) {
                                var phase =
                                    p.seed * 0.01 + t * pulseS * Math.PI * 2
                                var vis =
                                    1 -
                                    pulse +
                                    pulse * (0.5 + 0.5 * Math.sin(phase))
                                var r = hash01(
                                    (p.seed || i) + frameStep * 10007
                                )
                                if (r > vis) continue
                                alpha = (80 + 175 * vis) / 255
                            }
                            var rx = offX + (p.x - cropX) * scale
                            var ry = offY + (p.y - cropY) * scale
                            var radPx = Math.max(((p.z || 1) * scale) / 2, 0.6)
                            if (mix) {
                                ctx.fillStyle =
                                    hash01(p.seed || i) < __pc2t ? __pc2 : __pc1
                            }
                            ctx.globalAlpha = alpha
                            ctx.beginPath()
                            ctx.arc(rx, ry, radPx, 0, Math.PI * 2)
                            ctx.fill()
                        }
                        ctx.globalAlpha = 1
                        requestAnimationFrame(renderFrame)
                        return
                    }
                }
                init()
                    .then(function (ok) {
                        if (ok === false) return
                        __hideLoading()
                        requestAnimationFrame(renderFrame)
                    })
                    .catch(function (e) {
                        __showErr(e && e.message ? e.message : e)
                        __post("error", {
                            message: String(e && e.message ? e.message : e),
                        })
                    })
            })()
        </script>
    </body>
</html>
