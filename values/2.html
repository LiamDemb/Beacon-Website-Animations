<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width,height=device-height,initial-scale=1"
        />
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
                background: #fae6e6;
            }
        </style>
    </head>
    <body>
        <div
            id="protonBrushEmbed_1k1x99y4zkf"
            style="
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            "
        ></div>
        <div
            id="__pb_loading"
            style="
                position: absolute;
                left: 8px;
                top: 8px;
                font:
                    12px/1.35 ui-monospace,
                    SFMono-Regular,
                    Menlo,
                    monospace;
                color: #9aa4b2;
                pointer-events: none;
            "
        >
            Loading...
        </div>
        <div
            id="__pb_err"
            style="
                position: absolute;
                left: 8px;
                bottom: 8px;
                right: 8px;
                font:
                    12px/1.35 ui-monospace,
                    SFMono-Regular,
                    Menlo,
                    monospace;
                color: #ff6b6b;
                white-space: pre-wrap;
                pointer-events: none;
            "
        ></div>
        <script>
            ;(function () {
                var scene = {
                    meta: {
                        version: 3,
                        authoredWidth: 3140,
                        authoredHeight: 1352,
                        sourceWidth: 3140,
                        sourceHeight: 1352,
                        crop: null,
                        background: "#fae6e6",
                        particleColor: "#000000",
                        particleColor2: "#000000",
                        particleColor2Pct: 0,
                    },
                    mode: "spine",
                    animation: {
                        animate: 1,
                        flowSpeed: 30,
                        wobbleAmp: 10,
                        wobbleSpeed: 0.1,
                        pulseStrength: 0,
                        pulseSpeed: 0,
                        shapeContainment: 0.5,
                        shapeLeewayPx: 20,
                    },
                    recipe: {
                        density: 0.2,
                        densityCompExp: 0.75,
                        beamVariance: 15,
                        minSize: 3,
                        maxSize: 3,
                        organicWiggle: 0,
                        seed: 1423374481,
                    },
                    spines: [
                        {
                            id: "sp_0_0_0",
                            name: "Path 1.1",
                            visible: false,
                            order: 0,
                            q: 8,
                            pc: 211,
                            pb: "EDEgFVwxHxWoMRwV9DEWFUAyDhWLMgQV1jL4FCEz6RRrM9gUtTPFFP4zsBRGNJgUjjR+FNU0YxQbNUUUYDUlFKQ1AxTnNd4TKTa4E2o2kBOpNmYT5zY6EyQ3DRNgN90SmjesEtI3eRIJOEQSPzgOEnM41hGlOJ0R1ThiEQQ5JhEwOegQWzmqEIQ5aRCsOSgQ0TnmD/Q5og8VOl4PNDoYD1E60g5sOooOhDpCDps6+g2vOrANwTpmDdE6HA3eOtEM6TqGDPI6Ogz5Ou4L/TqiCwA7VgsAOwoL/Tq+Cvk6cgryOiYK6TraCd46jwnROkQJwTr6CK86sAibOmYIhDoeCGw61gdROo4HNDpIBxU6Agf0Ob4G0Tl6Bqw5OAaEOfcFWzm2BTA5eAUEOToF1Tj+BKU4wwRzOIoEPzhSBAk4HATSN+cDmje0A2A3gwMkN1MD5zYmA6k2+gJqNtACKTaoAuc1ggKkNV0CYDU7Ahs1GwLVNP0BjjTiAUY0yAH+M7ABtTObAWsziAEhM3cB1jJoAYsyXAFAMlIB9DFKAagxRAFcMUEBEDFAAcQwQQF4MEQBLDBKAeAvUgGVL1wBSi9oAf8udwG1LogBay6bASIusAHaLcgBki3iAUst/QEFLRsCwCw7AnwsXQI5LIIC9yuoArYr0AJ3K/oCOSsmA/wqUwPAKoMDhiq0A04q5wMXKhwE4SlSBK0pigR7KcMESyn+BBwpOgXwKHgFxSi2BZwo9wV0KDgGTyh6BiwovgYLKAIH7CdIB88njge0J9YHnCceCIUnZghxJ7AIXyf6CE8nRAlCJ48JNyfaCS4nJgonJ3IKIye+CiAnCgsgJ1YLIyeiCycn7gsuJzoMNyeGDEIn0QxPJxwNXydmDXEnsA2FJ/oNnCdCDrQnig7PJ9IO7CcYDwsoXg8sKKIPTyjmD3QoKBCcKGkQxSiqEPAo6BAcKSYRSyliEXspnRGtKdYR4SkOEhcqRBJOKnkShiqsEsAq3RL8Kg0TOSs6E3crZhO2K5AT9yu4Ezks3hN8LAMUwCwlFAUtRRRLLWMUki1+FNotmBQiLrAUay7FFLUu2BT/LukUSi/4FJUvBBXgLw4VLDAWFXgwHBXEMB8VEDEgFQ==",
                            rc: 211,
                        },
                        {
                            id: "sp_0_1_1",
                            name: "Path 1.2",
                            visible: false,
                            order: 1,
                            q: 8,
                            pc: 211,
                            pb: "EDEgFcQwIRV4MCQVLDAqFeAvMhWVLzwVSi9IFf8uVxW1LmgVay57FSIukBXaLagVki3CFUst3RUFLfsVwCwbFnwsPRY5LGIW9yuIFrYrsBZ3K9oWOSsGF/wqMxfAKmMXhiqUF04qxxcXKvwX4SkyGK0pahh7KaMYSyneGBwpGhnwKFgZxSiWGZwo1xl0KBgaTyhaGiwonhoLKOIa7CcoG88nbhu0J7YbnCf+G4UnRhxxJ5AcXyfaHE8nJB1CJ28dNye6HS4nBh4nJ1IeIyeeHiAn6h4gJzYfIyeCHycnzh8uJxogNydmIEInsSBQJ/wgXydGIXEnkCGFJ9ohnCciIrQnaiLPJ7Ii7Cf4IgsoPiMsKIIjTyjGI3QoCCScKEkkxSiKJPAoyCQcKQYlSylCJXspfSWtKbYl4SnuJRcqJCZOKlkmhiqMJsAqvSb8Ku0mOSsaJ3crRie2K3An9yuYJzksvid8LOMnwCwFKAUtJShLLUMoki1eKNoteCgiLpAoay6lKLUuuCj/LskoSi/YKJUv5CjgL+4oLDD2KHgw/CjEMP8oEDEAKVwx/yioMfwo9DH2KEAy7iiLMuQo1jLYKCEzyShrM7gotTOlKP4zkChGNHgojjReKNU0QygbNSUoYDUFKKQ14yfnNb4nKTaYJ2o2cCepNkYn5zYaJyQ37SZgN70mmjeMJtI3WSYJOCQmPzjuJXM4tiWlOH0l1ThCJQQ5BiUwOcgkWzmKJIQ5SSSsOQgk0TnGI/Q5giMVOj4jNDr4IlE6siJsOmoihDoiIps62iGvOpAhwTpGIdA6/CDeOrEg6TpmIPI6GiD5Os4f/TqCHwA7Nh8AO+oe/TqeHvk6Uh7yOgYe6Tq6Hd46bx3ROiQdwTraHK86kBybOkYchDr+G2w6thtROm4bNDooGxU64hr0OZ4a0TlaGqw5GBqEOdcZWzmWGTA5WBkEORoZ1TjeGKU4oxhzOGoYPzgyGAk4/BfSN8cXmjeUF2A3YxckNzMX5zYGF6k22hZqNrAWKTaIFuc1YhakNT0WYDUbFhs1+xXVNN0VjjTCFUY0qBX+M5AVtTN7FWszaBUhM1cV1jJIFYsyPBVAMjIV9DEqFagxJBVcMSEVEDEgFQ==",
                            rc: 211,
                        },
                        {
                            id: "sp_0_2_2",
                            name: "Path 1.3",
                            visible: false,
                            order: 2,
                            q: 8,
                            pc: 211,
                            pb: "EDEgFTcxYRVgMaIVizHgFbcxHhbmMVoWFjKVFkgyzxZ8MgYXsTI9F+gycRchM6QXWzPWF5czBRjTMzMYEjReGFE0iBiSNLAY1DTWGBc1+hhbNRwZoDU8GeY1WhktNnYZdTaPGb02pxkGN7wZUDfPGZo34BnlN+8ZMDj8GXs4BhrHOA4aEzkUGl85FxqrORga9zkXGkM6FBqPOg4a2zoGGiY7/BlyO/AZvDvhGQY80BlQPL0ZmTyoGeI8kBkpPXYZcD1aGbY9PBn7PRwZPz76GII+1hjEPrAYBT+IGEQ/XhiDPzIYwD8FGPs/1Rc1QKQXbkBxF6VAPRfaQAcXDkHPFkBBlRZxQVsWn0EeFsxB4RX3QaIVIEJiFUdCIBVsQt4Uj0KaFLBCVhTPQhAU60LKEwZDghMfQzoTNUPxEklDqBJbQ14Sa0MUEnlDyRGEQ30RjUMyEZRD5hCZQ5oQm0NOEJtDAhCZQ7YPlUNqD45DHg+FQ9IOeUOHDmxDPA5cQ/INSkOoDTZDXg0fQxYNBkPODOxChgzPQkAMsEL7C49CtgtrQnILRkIwCx9C7wr2Qa4KzEFwCp9BMgpwQfYJQEG7CQ5BgQnaQEoJpUATCW5A3wg1QKwI+z96CMA/SwiDPx0IRT/yBwU/yAfEPqAHgj56Bz8+Vgf7PTQHtj0UB3A99gYpPdoG4TzBBpk8qQZQPJQGBjyBBrw7cAZxO2EGJjtUBts6SgaPOkIGQzo8Bvc5OQarOTgGXzk5BhM5PAbHOEIGezhKBjA4VAblN2AGmjdvBlA3gAYGN5MGvTaoBnU2wAYtNtoG5jX2BqA1FAdbNTQHFzVWB9Q0egeSNKAHUjTIBxI08gfUMx4IlzNLCFszewghM6wI6DLfCLEyEwl8MkkJSDKBCRYyuwnmMfUJtzEyCooxbwpgMa4KNzHuChAxMAvrMHILyDC2C6cw+guIMEAMazCHDFAwzgw4MBYNITBfDQ0wqA37L/IN6y88Dt0vhw7SL9MOyS8eD8Ivag+9L7YPuy8CELsvThC9L5oQwi/mEMgvMhHSL34R3S/JEeovFBL6L14SDDCoEiEw8hI3MDoTUDCCE2swyhOIMBAUpzBVFMgwmhTrMN4UEDEgFQ==",
                            rc: 211,
                        },
                        {
                            id: "sp_0_3_3",
                            name: "Path 1.4",
                            visible: false,
                            order: 3,
                            q: 8,
                            pc: 211,
                            pb: "EDEgFekw3xTAMJ4UlTBgFGkwIhQ6MOYTCjCrE9gvcROkLzoTby8DEzgvzxL/LpwSxS5qEokuOxJNLg0SDi7iEc8tuBGOLZARTC1qEQktRhHFLCQRgCwEETos5hDzK8oQqyuxEGMrmRAaK4QQ0CpxEIYqYBA7KlEQ8ClEEKUpOhBZKTIQDSksEMEoKRB1KCgQKSgpEN0nLBCRJzIQRSc6EPomRBCuJlAQZCZfEBomcBDQJYMQhyWYED4lsBD3JMoQsCTmEGokBBElJCQR4SNGEZ4jahFcI5ARGyO4Edwi4hGdIg4SYCI7EiUiaxLrIZwSsiHPEnshAxNGITkTEiFxE+AgqxOvIOUTgSAiFFQgXxQpIJ4UACDeFNkfIBW0H2IVkR+mFXAf6hVRHzAWNR93FhofvhYBHwYX6x5PF9cemBfFHuIXtR4sGKcedxicHsMYkx4OGYweWhmHHqYZhR7yGYUePhqHHooaix7WGpIeIhubHm4bpx65G7QeBBzEHk4c1h6YHOoe4hwBHyodGh9yHTQfuh1RHwAecB9FHpEfih61H84e2h8QHwEgUR8qIJIfVCDQH4EgDiCwIEog4CCFIBIhvyBGIfYgeyEtIbIhYSHrIZQhJSLGIWAi9SGdIiMi2yJOIhsjeCJcI6AiniPGIuEj6iIlJAwjaiQsI7AkSiP3JGYjPyV/I4cllyPQJawjGia/I2Qm0COvJt8j+ibsI0Un9iORJ/4j3ScEJCkoByR1KAgkwSgHJA0pBCRZKf4jpSn2I/Ap7CM7KuAjhirRI9AqwCMaK60jYyuYI6srgCPzK2YjOixKI4AsLCPFLAwjCS3qIkwtxiKOLaAizi14Ig4uTiJMLiIiiS71IcUuxSH/LpQhOC9hIW8vLSGkL/cg2C+/IAowhSA6MEsgaTAOIJYw0R/AMJIf6TBSHxAxEB81Mc4eWDGKHnkxRh6YMQAetTG5HdAxch3oMSod/zHhHBMymBwlMk4cNTIEHEMyuRtOMm0bVzIiG14y1hpjMooaZTI+GmUy8hljMqYZXjJaGVgyDhlOMsIYQzJ3GDYyLBgmMuIXFDKYF/8xThfpMQYX0DG+FrUxdhaYMTAWeTHrFVgxphU1MWIVEDEgFQ==",
                            rc: 211,
                        },
                        {
                            id: "sp_0_4_4",
                            name: "Path 1.5",
                            visible: false,
                            order: 4,
                            q: 8,
                            pc: 211,
                            pb: "EDEgFeswYhXIMKYVpzDrFYgwMBZrMHYWUDC+FjcwBhchME4XDDCYF/ov4hfqLywY3S93GNIvwhjILw4Zwi9aGb0vphm7L/IZuy8+Gr0vihrCL9YayS8iG9IvbRvdL7kb6y8EHPsvThwNMJgcITDhHDgwKh1QMHIdazC5HYgwAB6nMEYeyDCKHuswzh4QMRAfNzFSH2Axkh+KMdEftzEOIOYxSyAWMoUgSDK/IHwy9yCxMi0h6DJhISEzlCFbM8UhlzP1IdQzIiISNE4iUjR4IpI0oCLUNMYiFzXqIls1DCOgNSwj5jVKIy02ZiN1NoAjvTaYIwY3rSNQN8AjmjfRI+U34CMwOOwjezj2I8c4/iMTOQQkXzkHJKs5CCT3OQckQzoEJI86/iPbOvYjJjvsI3E73yO8O9AjBjy/I1A8rCOZPJcj4Tx/Iyk9ZiNwPUojtj0sI/s9DCM/Puoigj7GIsQ+oCIFP3giRT9OIoM/IyLAP/Uh+z/GITVAlCFuQGEhpUAtIdpA9iAOQb8gQEGFIHBBSiCfQQ4gzEHQH/ZBkh8fQlEfRkIQH2tCzh6PQooesEJFHs9CAB7sQrodBkNyHR9DKh02Q+IcSkOYHFxDThxsQwQceUO5G4VDbhuOQyIblUPWGplDihqbQz4am0PyGZlDphmUQ1oZjUMOGYRDwxh5Q3cYa0MsGFtD4hdJQ5gXNUNPFx9DBhcGQ74W60J3Fs9CMBawQuoVj0KmFWxCYhVHQiAVIELeFPdBnhTMQV8Un0EiFHFB5RNAQasTDkFxE9pAOROlQAMTbkDPEjVAnBL7P2sSwD87EoM/DhJEP+IRBT+4EcQ+kBGCPmoRPz5GEfs9JBG2PQQRcD3mECk9yhDiPLAQmTyYEFA8gxAGPHAQvDtfEHI7UBAmO0QQ2zo6EI86MhBDOiwQ9zkpEKs5KBBfOSkQEzksEMc4MhB7ODoQMDhEEOU3URCaN2AQUDdxEAY3hBC9NpkQdTaxEC02yhDmNeYQoDUEEVs1JBEXNUYR1DRqEZI0kBFRNLgREjTiEdMzDRKXMzsSWzNqEiEznBLoMs8SsTIDE3wyOhNIMnETFjKrE+Yx5hO3MSIUizFgFGAxnhQ3Md8UEDEgFQ==",
                            rc: 211,
                        },
                        {
                            id: "sp_0_5_5",
                            name: "Path 1.6",
                            visible: true,
                            order: 5,
                            q: 8,
                            pc: 792,
                            pb: "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NyrwGT8q7hlXKuoZbirlGYYq4BmGKuAZnSrbGbUq1hnMKtAZ1CrOGesqyBkCK8IZGiu8GRorvBkxK7YZSCuvGV8rqBlnK6YZfSueGZQrlxmrK48ZqyuPGcIrhxnYK38Z7yt3GfcrdBkNLGwZIyxjGTosWhk6LFoZUCxRGWYsRxl8LD4Zgyw6GZksMBmvLCYZxSwcGcUsHBnaLBIZ8CwHGQUt/BgNLfgYIi3tGDct4hhMLdYYTC3WGGEtyhh2Lb4Yii2yGJEtrhimLaEYui2VGM8tiBjPLYgY4y17GPctbhgLLmEYEi5cGCUuThg5LkAYTS4zGE0uMxhgLiQYcy4WGIYuBxiNLgIYny7zF7Iu5RfFLtYXxS7WF9cuxhfqLrcX/C6nFwIvohcUL5IXJi+BFzgvcRc4L3EXSS9hF1ovUBdsL0AXci86F4IvKReTLxgXpC8GF6QvBhe0L/UWxS/jFtUv0hbaL8wW6i+5FvovpxYKMJUWCjCVFhkwgxYoMHAWNzBeFj0wVxZLMEQWWjAxFmkwHhZpMB4WdzALFoUw9xWTMOQVmDDdFaUwyRWzMLUVwDCiFcAwohXNMI0V2jB5FecwZRXrMF4V9zBJFQQxNRUQMSAV",
                            rc: 792,
                        },
                        {
                            id: "sp_0_6_6",
                            name: "Path 1.7",
                            visible: false,
                            order: 6,
                            q: 8,
                            pc: 211,
                            pb: "DiyxHc0rih2MK2EdTSs2HRArCh3TKtscmSqrHF8qeRwnKkUc8SkQHL0p2RuKKaAbWClmGykpKxv7KO4azyivGqYocBp+KC8aWCjtGTQoqhkSKGYZ8ichGdQn2xi4J5QYnidMGIcnBBhyJ7sXXidxF00nJxc/J9wWMieRFignRhYgJ/oVGieuFRcnYhUVJxYVFyfKFBonfhQgJzIUJyfmEzInmxM+J1ATTScFE14nuxJxJ3EShicoEp4n4BG4J5gR1CdREfInCxESKMYQNCiCEFgoPxB+KP0Ppii8D9AofQ/8KD4PKSkBD1kpxg6KKYwOvSlTDvEpHA4nKucNXyqzDZgqgQ3TKlANECsiDU0r9QyMK8oMzCuhDA4segxQLFUMlCwyDNgsEQweLfILZC3WC6wtuwv0LaILPC6MC4YueAvQLmYLGi9WC2UvSAuwLz0L/C80C0gwLQuUMCgL4DAmCywxJgt4MSgLxDEsCxAyMwtbMjwLpzJIC/IyVQs8M2ULhjN3C88ziwsYNKILYDS7C6c01QvuNPILMzURDHg1Mwy7NVYM/jV7DD82ogx/NssMvjb1DPw2Ig04N1ENczeBDa03sw3kN+cNGzgcDk84Uw6COIwOszjGDuM4AQ8ROT4PPDl8D2Y5vA+OOf0PtDk/ENg5ghD6OcYQGjoLETg6URFUOpgRbTrgEYU6KBKaOnESrTq7Er46BRPNOlAT2jqbE+Q65hPsOjIU8jp+FPU6yhT2OhYV9TpiFfI6rhXsOvoV5DpGFto6kRbOOtwWvzonF646cRebOrsXhToEGG46TBhUOpQYODrbGBo6IRn6OWYZ2DmqGbQ57RmOOS8aZjlvGjw5rxoQOe0a4zgqG7M4ZhuCOKAbTzjZGxs4EBzkN0UcrTd5HHM3qxw4N9sc/DYKHb82Nx2ANmEdQDaKHf41sR28NdYdeDX5HTM1Gh7uNDkepzRWHmA0cR4YNIkezzOgHoYztB48M8Ye8jLWHqcy5B5bMu8eEDL4HsQx/x54MQQfLDEGH+AwBh+UMAQfSDD/Hvwv+R6wL/AeZS/kHhov1x7QLscehi61HjwuoB70LYoerC1xHmQtVh4eLTke2CwaHpQs+R1QLNYdDiyxHQ==",
                            rc: 211,
                        },
                    ],
                    shape: null,
                    packed: null,
                }
                var root = document.getElementById(
                    "protonBrushEmbed_1k1x99y4zkf",
                )
                if (!root) {
                    return
                }
                var __pc1 = "#000000"
                var __pc2 = "#000000"
                var __pc2t = Math.max(0, Math.min(1, 0 / 100))
                var __errEl = document.getElementById("__pb_err")
                function __showErr(msg) {
                    try {
                        if (__errEl) {
                            __errEl.textContent = String(msg || "")
                        }
                    } catch (e) {}
                }
                var __loadEl = document.getElementById("__pb_loading")
                function __hideLoading() {
                    try {
                        if (__loadEl && __loadEl.parentNode) {
                            __loadEl.parentNode.removeChild(__loadEl)
                        }
                    } catch (e) {}
                }
                function __post(s, p) {
                    try {
                        if (window.parent && window.parent !== window) {
                            window.parent.postMessage(
                                Object.assign(
                                    { type: "protonBrushEmbed", status: s },
                                    p || {},
                                ),
                                "*",
                            )
                        }
                    } catch (e) {}
                }
                __post("boot")
                window.addEventListener("error", function (e) {
                    __showErr((e && e.message) || e)
                    __post("error", { message: (e && e.message) || String(e) })
                })
                window.addEventListener("unhandledrejection", function (e) {
                    __showErr((e && e.reason) || e)
                    __post("rejection", {
                        message: String((e && e.reason) || e),
                    })
                })
                var canvas = document.createElement("canvas")
                canvas.style.width = "100%"
                canvas.style.height = "100%"
                canvas.style.display = "block"
                canvas.style.position = "absolute"
                canvas.style.left = "0"
                canvas.style.top = "0"
                root.appendChild(canvas)
                var ctx = canvas.getContext("2d", {
                    alpha: false,
                    desynchronized: true,
                })
                var dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1))
                var authoredW = scene.meta.authoredWidth || 600,
                    authoredH = scene.meta.authoredHeight || 400
                var sourceW = scene.meta.sourceWidth || authoredW,
                    sourceH = scene.meta.sourceHeight || authoredH
                var crop = scene.meta.crop || null
                var cropX = crop ? crop.x || 0 : 0
                var cropY = crop ? crop.y || 0 : 0
                var scale = 1,
                    offX = 0,
                    offY = 0,
                    viewW = 0,
                    viewH = 0,
                    densityScale = 1,
                    __lastDensityScale = 1
                var __postedResize = 0
                function resize() {
                    var r = root.getBoundingClientRect()
                    viewW = Math.max(1, Math.floor(r.width))
                    viewH = Math.max(1, Math.floor(r.height))
                    if (viewH <= 1) {
                        viewH = Math.max(1, window.innerHeight || 1)
                    }
                    canvas.width = Math.floor(viewW * dpr)
                    canvas.height = Math.floor(viewH * dpr)
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
                    scale = Math.min(viewW / authoredW, viewH / authoredH)
                    offX = (viewW - authoredW * scale) / 2
                    offY = (viewH - authoredH * scale) / 2
                    var exp =
                        scene &&
                        scene.recipe &&
                        typeof scene.recipe.densityCompExp === "number"
                            ? scene.recipe.densityCompExp
                            : 0
                    var newDensityScale = Math.pow(
                        Math.max(1e-6, scale),
                        exp || 0,
                    )
                    densityScale = newDensityScale
                    if (newDensityScale !== __lastDensityScale) {
                        __lastDensityScale = newDensityScale
                        if (typeof particles !== "undefined") {
                            particles = null
                        }
                    }
                    if (!__postedResize) {
                        __postedResize = 1
                        __post("resize", {
                            viewW: viewW,
                            viewH: viewH,
                            authoredW: authoredW,
                            authoredH: authoredH,
                            scale: scale,
                            offX: offX,
                            offY: offY,
                        })
                    }
                }
                window.addEventListener("resize", resize)
                resize()
                var __tries = 0
                ;(function __settle() {
                    __tries++
                    resize()
                    if (__tries < 30) {
                        setTimeout(__settle, 33)
                    }
                })()
                function hash(n) {
                    n = (n << 13) ^ n
                    return (
                        ((n * (n * n * 15731 + 789221) + 1376312589) &
                            0x7fffffff) /
                        2147483647
                    )
                }
                function lerp(a, b, t) {
                    return a + (b - a) * t
                }
                function smooth(t) {
                    return t * t * (3 - 2 * t)
                }
                function noise2(x, y) {
                    var xi = Math.floor(x),
                        yi = Math.floor(y)
                    var xf = x - xi,
                        yf = y - yi
                    var a = hash(xi * 374761 + yi * 668265)
                    var b = hash((xi + 1) * 374761 + yi * 668265)
                    var c = hash(xi * 374761 + (yi + 1) * 668265)
                    var d = hash((xi + 1) * 374761 + (yi + 1) * 668265)
                    var u = smooth(xf),
                        v = smooth(yf)
                    return lerp(lerp(a, b, u), lerp(c, d, u), v)
                }
                function hash01(seed) {
                    var x = Math.sin(seed * 12.9898) * 43758.5453
                    return x - Math.floor(x)
                }
                function mulberry32(a) {
                    return function () {
                        var t = (a += 0x6d2b79f5)
                        t = Math.imul(t ^ (t >>> 15), t | 1)
                        t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
                        return ((t ^ (t >>> 14)) >>> 0) / 4294967296
                    }
                }
                function makeGaussian(rand) {
                    var spare = null
                    return function (mean, sd) {
                        if (spare !== null) {
                            var v = spare
                            spare = null
                            return mean + sd * v
                        }
                        var u = 0,
                            v = 0
                        while (u === 0) u = rand()
                        while (v === 0) v = rand()
                        var mag = Math.sqrt(-2 * Math.log(u))
                        var z0 = mag * Math.cos(2 * Math.PI * v)
                        var z1 = mag * Math.sin(2 * Math.PI * v)
                        spare = z1
                        return mean + sd * z0
                    }
                }
                function b64ToU8(b64) {
                    var bin = atob(b64 || "")
                    var len = bin.length
                    var u8 = new Uint8Array(len)
                    for (var i = 0; i < len; i++) u8[i] = bin.charCodeAt(i)
                    return u8
                }
                var mode = "spine"
                var anim = scene.animation || {}
                var recipe = scene.recipe || {}
                function map(v, a1, a2, b1, b2) {
                    return b1 + ((v - a1) * (b2 - b1)) / Math.max(1e-6, a2 - a1)
                }
                var spines = scene.spines || []
                if ((!spines || !spines.length) && scene.spine)
                    spines = [scene.spine]
                var spCount = spines.length | 0
                var spQ = new Array(spCount),
                    spN = new Array(spCount),
                    spPts = new Array(spCount),
                    spCum = new Array(spCount),
                    spLen = new Array(spCount)
                for (var sidx = 0; sidx < spCount; sidx++) {
                    var s = spines[sidx]
                    if (!s || !s.pb || !s.pc) {
                        spN[sidx] = 0
                        spLen[sidx] = 0
                        continue
                    }
                    spQ[sidx] = s.q || 1
                    spN[sidx] = s.pc | 0
                    var u8 = b64ToU8(s.pb)
                    spPts[sidx] = new Int16Array(u8.buffer)
                    var cum = new Float32Array(spN[sidx])
                    cum[0] = 0
                    var L = 0
                    for (var i = 0; i < spN[sidx] - 1; i++) {
                        var ax = spPts[sidx][i * 2] / spQ[sidx],
                            ay = spPts[sidx][i * 2 + 1] / spQ[sidx]
                        var bx = spPts[sidx][(i + 1) * 2] / spQ[sidx],
                            by = spPts[sidx][(i + 1) * 2 + 1] / spQ[sidx]
                        L += Math.hypot(bx - ax, by - ay)
                        cum[i + 1] = L
                    }
                    spCum[sidx] = cum
                    spLen[sidx] = L
                }
                function pointAtS(si, s) {
                    var pts = spPts[si],
                        cum = spCum[si],
                        N = spN[si] | 0,
                        L = spLen[si] || 0,
                        Q = spQ[si] || 1
                    if (!pts || !cum || N < 2 || L <= 0) {
                        return { x: 0, y: 0, nx: 0, ny: 1 }
                    }
                    var ss = s % L
                    if (ss < 0) ss += L
                    var lo = 0,
                        hi = N - 2
                    while (lo <= hi) {
                        var mid = (lo + hi) >> 1
                        if (ss < cum[mid]) hi = mid - 1
                        else if (ss > cum[mid + 1]) lo = mid + 1
                        else {
                            lo = mid
                            break
                        }
                    }
                    var idx = Math.max(0, Math.min(N - 2, lo))
                    var ax = pts[idx * 2] / Q,
                        ay = pts[idx * 2 + 1] / Q
                    var bx = pts[(idx + 1) * 2] / Q,
                        by = pts[(idx + 1) * 2 + 1] / Q
                    var segLen = Math.max(1e-6, cum[idx + 1] - cum[idx])
                    var t = (ss - cum[idx]) / segLen
                    var x = ax + (bx - ax) * t,
                        y = ay + (by - ay) * t
                    var tx = (bx - ax) / segLen,
                        ty = (by - ay) / segLen
                    return { x: x, y: y, nx: -ty, ny: tx }
                }
                var density = +recipe.density || 1
                var beam = +recipe.beamVariance || 20
                var minS = +recipe.minSize || 1
                var maxS = +recipe.maxSize || 8
                var particles = null
                function buildSpineParticles() {
                    if (particles) return particles
                    particles = []
                    var seed = recipe.seed >>> 0 || 1
                    var rand = mulberry32(seed)
                    var gauss = makeGaussian(rand)
                    var keepCycle = 16
                    var keepMax = Math.min(
                        keepCycle,
                        Math.round(keepCycle * Math.min(1, densityScale || 1)),
                    )
                    var CL = 4
                    for (var si = 0; si < spCount; si++) {
                        var s = spines[si] || {}
                        if (s.visible === false) continue
                        var pts = spPts[si],
                            cum = spCum[si],
                            N = spN[si] | 0,
                            Q = spQ[si] || 1
                        if (!pts || !cum || N < 2) continue
                        for (var i = 0; i < N - 1; i++) {
                            var ax = pts[i * 2] / Q,
                                ay = pts[i * 2 + 1] / Q
                            var bx = pts[(i + 1) * 2] / Q,
                                by = pts[(i + 1) * 2 + 1] / Q
                            var dx = bx - ax,
                                dy = by - ay
                            var segLen = Math.hypot(dx, dy)
                            if (segLen < 1e-6) continue
                            var count = Math.min(
                                2500,
                                Math.ceil(segLen * density),
                            )
                            var segStartS = cum[i] || 0
                            for (var j = 0; j < count; j++) {
                                if (
                                    keepMax < keepCycle &&
                                    j % keepCycle >= keepMax
                                )
                                    continue
                                var tt = j / Math.max(1, count)
                                var baseS = segStartS + tt * segLen
                                var offN = gauss(0, beam)
                                var offT = gauss(0, beam * 0.15)
                                var limN = beam * CL
                                var limT = beam * 0.15 * CL
                                if (offN > limN) offN = limN
                                else if (offN < -limN) offN = -limN
                                if (offT > limT) offT = limT
                                else if (offT < -limT) offT = -limT
                                var dist = Math.abs(offN)
                                var size = map(dist, 0, beam * 2, maxS, minS)
                                if (size < minS) size = minS
                                else if (size > maxS) size = maxS
                                particles.push({
                                    si: si,
                                    s: baseS,
                                    n: offN,
                                    t: offT,
                                    z: size,
                                    seed:
                                        ((si + 1) * 100000000 +
                                            i * 100000 +
                                            j) >>>
                                        0,
                                })
                            }
                        }
                    }
                    return particles
                }
                function init() {
                    if (mode === "shape") {
                        var sh = scene.shape || {}
                        var svg = sh.svg || ""
                        if (!svg) {
                            __showErr("Shape mode: missing SVG")
                            return Promise.resolve(false)
                        }
                        var leeway = (anim.shapeLeewayPx || 0) | 0
                        return buildShapeMask(svg, leeway).then(
                            function (mask) {
                                shapeMask = mask
                                var stride = 2
                                var r = bboxAndPts(
                                    mask.core,
                                    mask.w,
                                    mask.h,
                                    stride,
                                )
                                shapePts = r.pts
                                __post("shape", { pts: shapePts.length })
                                return true
                            },
                        )
                    }
                    return Promise.resolve(true)
                }
                var __postedParticles = 0
                function renderFrame(tms) {
                    var t = tms / 1000
                    var wobA = anim.wobbleAmp || 0,
                        wobS = anim.wobbleSpeed || 0,
                        pulse = anim.pulseStrength || 0,
                        pulseS = anim.pulseSpeed || 0
                    var frameStep = Math.floor(
                        t * Math.max(0.0001, pulseS) * 10,
                    )
                    ctx.globalAlpha = 1
                    ctx.fillStyle = "#fae6e6"
                    ctx.fillRect(0, 0, viewW, viewH)
                    ctx.fillStyle = __pc1
                    if (mode === "shape") {
                        var ps = buildShapeParticles()
                        if (!__postedParticles) {
                            __postedParticles = 1
                            __post("particles", { count: ps.length })
                            __hideLoading()
                        }
                        var cont = +anim.shapeContainment || 0.5
                        var mix = __pc2t > 0
                        for (var i = 0; i < ps.length; i++) {
                            var p = ps[i]
                            if (anim.animate) {
                                if (wobA > 0) {
                                    var ax =
                                        (noise2(p.seed * 0.01, t * wobS) -
                                            0.5) *
                                        2
                                    var ay =
                                        (noise2(p.seed * 0.02, 100 + t * wobS) -
                                            0.5) *
                                        2
                                    p.vx += ax * (wobA * 0.12)
                                    p.vy += ay * (wobA * 0.12)
                                }
                                p.vx *= 0.9
                                p.vy *= 0.9
                                p.x += p.vx
                                p.y += p.vy
                                var inCore =
                                    alphaAt(shapeMask, p.x, p.y, "core") > 0
                                if (!inCore) {
                                    var inLew =
                                        alphaAt(shapeMask, p.x, p.y, "leeway") >
                                        0
                                    var k = inLew
                                        ? 0.02 + 0.12 * cont
                                        : 0.06 + 0.22 * cont
                                    p.vx += (p.x0 - p.x) * k
                                    p.vy += (p.y0 - p.y) * k
                                    if (!inLew) {
                                        var cl = findNearestInside(
                                            shapeMask,
                                            p.x,
                                            p.y,
                                        )
                                        if (cl) {
                                            p.x = cl.x
                                            p.y = cl.y
                                            p.vx *= 0.2
                                            p.vy *= 0.2
                                        }
                                    }
                                }
                            }
                            var alpha = 200 / 255
                            if (anim.animate && pulse > 0) {
                                var phase =
                                    p.seed * 0.01 + t * pulseS * Math.PI * 2
                                var vis =
                                    1 -
                                    pulse +
                                    pulse * (0.5 + 0.5 * Math.sin(phase))
                                var r = hash01(
                                    (p.seed || i) + frameStep * 10007,
                                )
                                if (r > vis) continue
                                alpha = (80 + 175 * vis) / 255
                            }
                            var rx = offX + (p.x - cropX) * scale
                            var ry = offY + (p.y - cropY) * scale
                            var radPx = Math.max(((p.z || 1) * scale) / 2, 0.6)
                            if (mix) {
                                ctx.fillStyle =
                                    hash01(p.seed || i) < __pc2t ? __pc2 : __pc1
                            }
                            ctx.globalAlpha = alpha
                            ctx.beginPath()
                            ctx.arc(rx, ry, radPx, 0, Math.PI * 2)
                            ctx.fill()
                        }
                        ctx.globalAlpha = 1
                        requestAnimationFrame(renderFrame)
                        return
                    }
                    var flow = anim.flowSpeed || 0
                    var ps = buildSpineParticles()
                    if (!__postedParticles) {
                        __postedParticles = 1
                        __post("particles", { count: ps.length })
                        __hideLoading()
                    }
                    var mix = __pc2t > 0
                    for (var i = 0; i < ps.length; i++) {
                        var p = ps[i]
                        var si = p.si || 0
                        var x = 0,
                            y = 0,
                            alpha = 200 / 255
                        var s = (p.s || 0) + (anim.animate ? flow * t : 0)
                        var base = pointAtS(si, s + (p.t || 0))
                        x = base.x + base.nx * (p.n || 0)
                        y = base.y + base.ny * (p.n || 0)
                        if (anim.animate && wobA > 0) {
                            var pr = p.seed || i
                            var n1 = noise2(pr * 0.01, t * wobS) - 0.5
                            var n2 = noise2(pr * 0.02, 100 + t * wobS) - 0.5
                            x += n1 * 2 * wobA
                            y += n2 * 2 * wobA
                        }
                        var L = spLen[si] || 0
                        if (anim.animate && pulse > 0 && L > 0) {
                            var phase =
                                (s / L) * Math.PI * 2 + t * pulseS * Math.PI * 2
                            var vis =
                                1 -
                                pulse +
                                pulse * (0.5 + 0.5 * Math.sin(phase))
                            var pr2 = (p.seed || i) + frameStep * 10007
                            var r = hash01(pr2)
                            if (r > vis) continue
                            alpha = (80 + 175 * vis) / 255
                        }
                        var rx = offX + (x - cropX) * scale
                        var ry = offY + (y - cropY) * scale
                        var radPx = Math.max(((p.z || 1) * scale) / 2, 0.6)
                        if (mix) {
                            ctx.fillStyle =
                                hash01(p.seed || i) < __pc2t ? __pc2 : __pc1
                        }
                        ctx.globalAlpha = alpha
                        ctx.beginPath()
                        ctx.arc(rx, ry, radPx, 0, Math.PI * 2)
                        ctx.fill()
                    }
                    ctx.globalAlpha = 1
                    requestAnimationFrame(renderFrame)
                }
                init()
                    .then(function (ok) {
                        if (ok === false) return
                        __hideLoading()
                        requestAnimationFrame(renderFrame)
                    })
                    .catch(function (e) {
                        __showErr(e && e.message ? e.message : e)
                        __post("error", {
                            message: String(e && e.message ? e.message : e),
                        })
                    })
            })()
        </script>
    </body>
</html>
